import {
  EntryPoint,
  IAggregatedAccount__factory, IEntryPoint__factory,
  IPaymaster__factory, SenderCreator__factory
} from '@account-abstraction/contracts'
import { JsonRpcProvider } from '@ethersproject/providers'
import { hexZeroPad, Interface, keccak256 } from 'ethers/lib/utils'
import { BundlerCollectorReturn } from './BundlerCollectorTracer'
import { requireCond } from './utils'
import { inspect } from 'util'

import Debug from 'debug'
import { UserOperation } from './modules/moduleUtils'
import { StakeInfo, ValidationErrors, ValidationResult } from './modules/ValidationManager'
import { BigNumber, BigNumberish } from 'ethers'
import {
  TestStorageAccount__factory
} from '../src/types/factories/contracts/tests/TestStorageAccount.sol'
import {
  TestOpcodesAccountFactory__factory,
  TestOpcodesAccount__factory
} from './types/factories/contracts/tests/TestOpcodesAccount.sol'

const debug = Debug('aa.handler.opcodes')

/**
 * helper method: check if currently connected node is geth.
 * @param provider
 */
export async function isGeth (provider: JsonRpcProvider): Promise<boolean> {
  const p = provider.send as any
  if (p._clientVersion == null) {
    p._clientVersion = await provider.send('web3_clientVersion', [])
  }

  debug('client version', p._clientVersion)
  return p._clientVersion?.match('Geth') != null
}

interface CallEntry {
  to: string
  type: string // call opcode
  method: string // parsed method, or signash if unparsed
  revert?: any // parsed output from REVERT
  return?: any // parsed method output.
  value?: BigNumberish
}

/**
 * parse all call operation in the trace.
 * notes:
 * - entries are ordered by the return (so nested call appears before its outer call
 * - last entry is top-level return from "simulateValidation". it as ret and rettype, but no type or address
 * @param tracerResults
 */
function parseCallStack (tracerResults: BundlerCollectorReturn): CallEntry[] {
  const abi = Object.values([
    ...TestOpcodesAccount__factory.abi,
    ...TestOpcodesAccountFactory__factory.abi,
    ...TestStorageAccount__factory.abi,
    ...SenderCreator__factory.abi,
    ...IEntryPoint__factory.abi,
    ...IPaymaster__factory.abi,
    ...IAggregatedAccount__factory.abi
  ].reduce((set, entry) => {
    const key = `${entry.name}(${entry.inputs.map(i => i.type).join(',')})`
    // console.log('key=', key, keccak256(Buffer.from(key)).slice(0,10))
    return {
      ...set,
      [key]: entry
    }
  }, {})) as any

  const xfaces = new Interface(abi)

  function callCatch<T, T1> (x: () => T, def: T1): T | T1 {
    try {
      return x()
    } catch {
      return def
    }
  }

  const out: CallEntry[] = []
  const stack: any[] = []
  tracerResults.calls
    .filter(x => !x.type.startsWith('depth'))
    .forEach(c => {
      if (c.type.match(/REVERT|RETURN/) != null) {
        const top = stack.splice(-1)[0] ?? {
          type: 'top',
          method: 'validateUserOp'
        }
        const returnData: string = (c as any).data
        if (top.type.match(/CREATE/) != null) {
          out.push({
            to: top.to,
            type: top.type,
            method: '',
            return: `len=${returnData.length}`
          })
        } else {
          const method = callCatch(() => xfaces.getFunction(top.method), top.method)
          if (c.type === 'REVERT') {
            const parsedError = callCatch(() => xfaces.parseError(returnData), returnData)
            out.push({
              to: top.to,
              type: top.type,
              method: method.name,
              value: top.value,
              revert: parsedError
            })
          } else {
            const ret = callCatch(() => xfaces.decodeFunctionResult(method, returnData), returnData)
            out.push({
              to: top.to,
              type: top.type,
              method: method.name ?? method,
              return: ret
            })
          }
        }
      } else {
        stack.push(c)
      }
    })

  // TODO: verify that stack is empty at the end.

  return out
}

/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak array of buffers that were given to keccak in the transaction
 */
function parseEntitySlots (stakeInfoEntities: {[addr: string]: StakeInfo | undefined}, keccak: string[]): { [addr: string]: Set<string> } {
  // for each entity (sender, factory, paymaster), hold the valid slot addresses
  // valid: the slot was generated by keccak(entity || ...) or by keccak( ... || OWN) where OWN is previous allowed slot
  const entitySlots: { [addr: string]: Set<string> } = {}

  keccak.forEach(k => {
    const value = keccak256(k).slice(2)
    Object.values(stakeInfoEntities).forEach(info => {
      const addr = info?.addr?.toLowerCase()
      if (addr == null) return
      const addrPadded = hexZeroPad(addr.toLowerCase(), 32)
      if (entitySlots[addr] == null) {
        entitySlots[addr] = new Set<string>()
      }

      const currentEntitySlots = entitySlots[addr]
      if (k.startsWith(addrPadded)) {
        // console.log('added mapping (balance) slot', value)
        currentEntitySlots.add(value)
      }
      if (k.length === 130 && currentEntitySlots.has(k.slice(-64))) {
        // console.log('added double-mapping (allowance) slot', value)
        currentEntitySlots.add(value)
      }
    })
  })

  return entitySlots
}

/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param validationResult output from simulateValidation
 * @param entryPoint the entryPoint that hosted the "simulatedValidation" traced call.
 */
export function parseScannerResult (userOp: UserOperation, tracerResults: BundlerCollectorReturn, validationResult: ValidationResult, entryPoint: EntryPoint): void {
  debug('=== simulation result:', inspect(tracerResults, true, 10, true))
  // todo: block access to no-code addresses (might need update to tracer)

  const entryPointAddress = entryPoint.address.toLowerCase()

  const bannedOpCodes = new Set(['GASPRICE', 'GASLIMIT', 'DIFFICULTY', 'TIMESTAMP', 'BASEFEE', 'BLOCKHASH', 'NUMBER', 'SELFBALANCE', 'BALANCE', 'ORIGIN', 'GAS', 'CREATE', 'COINBASE', 'SELFDESTRUCT'])

  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  if (Object.values(tracerResults.numberLevels).length < 2) {
    // console.log('calls=', result.calls.map(x=>JSON.stringify(x)).join('\n'))
    // console.log('debug=', result.debug)
    throw new Error('Unexpected traceCall result: no NUMBER opcodes, and not REVERT')
  }
  const callStack = parseCallStack(tracerResults)

  const callInfoEntryPoint = callStack.find(call =>
    call.to === entryPointAddress &&
    (call.method !== '0x' && call.method !== 'depositTo'))
  requireCond(callInfoEntryPoint == null,
    `illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`,
    ValidationErrors.OpcodeValidation
  )

  requireCond(
    callStack.find(call => call.to !== entryPointAddress &&
    BigNumber.from(call.value ?? 0) !== BigNumber.from(0)) != null,
    'May not may CALL with value',
    ValidationErrors.OpcodeValidation)

  const sender = userOp.sender.toLowerCase()
  // stake info per "number" level (factory, sender, paymaster)
  // we only use stake info if we notice a memory reference that require stake
  const stakeInfoEntities = {
    factory: validationResult.factoryInfo,
    account: validationResult.senderInfo,
    paymaster: validationResult.paymasterInfo
  }

  const entitySlots: { [addr: string]: Set<string> } = parseEntitySlots(stakeInfoEntities, tracerResults.keccak)

  Object.entries(stakeInfoEntities).forEach(([entityTitle, entStakes], index) => {
    const entityAddr = entStakes?.addr ?? ''
    const currentNumLevel = tracerResults.numberLevels[index]
    const opcodes = currentNumLevel.opcodes
    const access = currentNumLevel.access

    requireCond(!(currentNumLevel.oog ?? false),
      `${entityTitle} internally reverts on oog`, ValidationErrors.OpcodeValidation)
    Object.keys(opcodes).forEach(opcode =>
      requireCond(!bannedOpCodes.has(opcode), `${entityTitle} uses banned opcode: ${opcode}`, ValidationErrors.OpcodeValidation)
    )
    if (entityTitle === 'factory') {
      requireCond((opcodes.CREATE2 ?? 0) <= 1, `${entityTitle} with too many CREATE2`, ValidationErrors.OpcodeValidation)
    } else {
      requireCond(opcodes.CREATE2 == null, `${entityTitle} uses banned opcode: CREATE2`, ValidationErrors.OpcodeValidation)
    }

    Object.entries(access).forEach(([addr, {
      reads,
      writes
    }]) => {
      // testing read/write access on contract "addr"
      if (addr === sender) {
        // allowed to access sender's storage
        return
      }
      if (addr === entryPointAddress) {
        // ignore storage access on entryPoint (balance/deposit of entities.
        // we block them on method calls: only allowed to deposit, never to read
        return
      }
      let requireStakeSlot: string | undefined
      [...Object.keys(writes), ...Object.keys(reads)].forEach(slot => {
        // slot associated with sender is allowed (e.g. token.balanceOf(sender)
        // but not during initial UserOp (if there is an initCode)
        if (entitySlots[sender]?.has(slot)) {
          if (userOp.initCode.length <= 2 || addr === entryPoint.address) {
            return
          }
        }
        if (entitySlots[entityAddr]?.has(slot)) {
          // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
          requireStakeSlot = slot
        } else if (addr === entityAddr) {
          // accessing storage member of entity itself requires stake.
          requireStakeSlot = slot
        } else {
          // accessing arbitrary storage of another contract
          const readWrite = Object.keys(writes).includes(addr) ? 'write to' : 'read from'
          requireCond(false, `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`, ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes?.addr })
        }
      })

      // match address to factory/account/paymaster (or leave it as address if none of these)
      function nameAddr (addr: string, currentEntity: string): string {
        const [title] = Object.entries(stakeInfoEntities).find(([title, info]) =>
          info?.addr.toLowerCase() === addr.toLowerCase()) ?? []
        if (title == null) { return addr }
        return title
      }
      requireCondAndStake(requireStakeSlot != null, entStakes,
        `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`)
    })

    if (entityTitle === 'paymaster') {
      const validatePaymasterUserOp = callStack.find(call => call.method === 'validatePaymasterUserOp' && call.to === entityAddr)
      const context = validatePaymasterUserOp?.return?.context
      requireCondAndStake(context != null && context !== '0x', entStakes,
        'unstaked paymaster must not return context')
    }

    // helper method: if condition is true, then entity must be staked.
    function requireCondAndStake (cond: boolean, entStake: StakeInfo | undefined, failureMessage: string): void {
      if (!cond) {
        return
      }
      if (entStakes == null) {
        throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`)
      }
      requireCond(BigNumber.from(1).lt(entStakes.stake) && BigNumber.from(1).lt(entStakes.unstakeDelaySec),
        failureMessage, ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes?.addr })

      // TODO: check real minimum stake values
    }
  })
}
