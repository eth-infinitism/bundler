// This file contains references to validation rules, in the format [xxx-###]
// where xxx is OP/STO/COD/EP/SREP/EREP/UREP/ALT, and ### is a number
// the validation rules are defined in erc-aa-validation.md
import Debug from 'debug'
import { BigNumber } from 'ethers'
import { hexZeroPad, keccak256 } from 'ethers/lib/utils'
import { inspect } from 'util'

import { AccessInfo, BundlerTracerResult, MethodInfo, TopLevelCallInfo } from './BundlerCollectorTracer'
import {
  OperationBase,
  RpcError,
  StakeInfo,
  StorageMap,
  ValidationErrors,
  mapOf,
  requireCond,
  toBytes32, AddressZero, UserOperation
} from '@account-abstraction/utils'

import { ValidationResult } from './IValidationManager'

const debug = Debug('aa.handler.opcodes')

/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * removed rule: keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak array of buffers that were given to keccak in the transaction
 */
function parseEntitySlots (stakeInfoEntities: { [addr: string]: StakeInfo | undefined }, keccak: string[]): {
  [addr: string]: Set<string>
} {
  // for each entity (sender, factory, paymaster), hold the valid slot addresses
  // valid: the slot was generated by keccak(entity || ...)
  const entitySlots: { [addr: string]: Set<string> } = {}

  keccak.forEach(k => {
    Object.values(stakeInfoEntities).forEach(info => {
      const addr = info?.addr?.toLowerCase()
      if (addr == null) return
      const addrPadded = toBytes32(addr)
      if (entitySlots[addr] == null) {
        entitySlots[addr] = new Set<string>()
      }

      const currentEntitySlots = entitySlots[addr]

      // valid slot: the slot was generated by keccak(entityAddr || ...)
      if (k.startsWith(addrPadded)) {
        // console.log('added mapping (balance) slot', value)
        currentEntitySlots.add(keccak256(k))
      }
      // disabled 2nd rule: .. or by keccak( ... || OWN) where OWN is previous allowed slot
      // if (k.length === 130 && currentEntitySlots.has(k.slice(-64))) {
      //   // console.log('added double-mapping (allowance) slot', value)
      //   currentEntitySlots.add(value)
      // }
    })
  })

  return entitySlots
}

//
// // method-signature for calls from entryPoint
// const callsFromEntryPointMethodSigs1: { [key: string]: string } = {
//   factory: SenderCreator__factory.createInterface().getSighash('createSender'),
//   account: IAccount__factory.createInterface().getSighash('validateUserOp'),
//   paymaster: IPaymaster__factory.createInterface().getSighash('validatePaymasterUserOp')
// }
//
// // todo: use a selector for factory or refactor the tracer for RIP-7560
// const callsFromEntryPointMethodSigs: { [key: string]: string } = {
//   account: '0xbf45c166',
//   paymaster: '0xe0e6183a',
// }

function getEntityTitle (userOp: OperationBase, entityAddress: string): string {
  if (userOp.sender.toLowerCase() === entityAddress.toLowerCase()) {
    return 'account'
  } else if (userOp.factory?.toLowerCase() === entityAddress.toLowerCase()) {
    return 'factory'
  } else if (userOp.paymaster?.toLowerCase() === entityAddress.toLowerCase()) {
    return 'paymaster'
  } else {
    throw new RpcError(`could not find entity name for address ${entityAddress}. This should not happen. This is a bug.`, 0)
  }
}

// opcodes from [OP-011]
// (CREATE, CREATE2 have special rules, OP-031, OP-032)
const bannedOpCodes = new Set(['GASPRICE', 'GASLIMIT', 'DIFFICULTY', 'TIMESTAMP', 'BASEFEE', 'BLOCKHASH', 'NUMBER', 'ORIGIN', 'GAS', 'COINBASE', 'SELFDESTRUCT', 'RANDOM', 'PREVRANDAO', 'INVALID'])
// opcodes allowed in staked entities [OP-080]
const opcodesOnlyInStakedEntities = new Set(['BALANCE', 'SELFBALANCE'])

/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param validationResult output from simulateValidation
 * @param entryPointAddress the entryPoint that hosted the "simulatedValidation" traced call.
 * @return list of contract addresses referenced by this UserOp
 */
export function tracerResultParser (
  userOp: OperationBase,
  tracerResults: BundlerTracerResult,
  validationResult: ValidationResult,
  entryPointAddress: string
): [string[], StorageMap] {
  debug('=== simulation result:', inspect(tracerResults, true, 10, true))
  // todo: block access to no-code addresses (might need update to tracer)

  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  if (Object.values(tracerResults.callsFromEntryPoint).length < 1) {
    throw new Error('Unexpected traceCall result: no calls from entrypoint.')
  }
  if (tracerResults.calls != null) {
    const callStack = tracerResults.calls.filter((call: any) => call.topLevelTargetAddress == null) as MethodInfo[]
    // [OP-052], [OP-053]
    const callInfoEntryPoint = callStack.find(call =>
      call.to?.toLowerCase() === entryPointAddress?.toLowerCase() && call.from?.toLowerCase() !== entryPointAddress?.toLowerCase() &&
      (call.method !== '0x' && call.method !== 'depositTo'))
    // [OP-054]
    requireCond(callInfoEntryPoint == null,
      `illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`,
      ValidationErrors.OpcodeValidation
    )

    // [OP-061]
    const illegalNonZeroValueCall = callStack.find(
      call =>
        call.to?.toLowerCase() !== entryPointAddress?.toLowerCase() &&
        !BigNumber.from(call.value ?? 0).eq(0))
    requireCond(
      illegalNonZeroValueCall == null,
      'May not may CALL with value',
      ValidationErrors.OpcodeValidation)
  }

  const sender = userOp.sender.toLowerCase()
  // stake info per "number" level (factory, sender, paymaster)
  // we only use stake info if we notice a memory reference that require stake
  const stakeInfoEntities = {
    [sender]: validationResult.senderInfo
  }
  const factory = userOp.factory?.toLowerCase()
  if (factory != null) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    stakeInfoEntities[factory] = validationResult.factoryInfo!
  }
  const paymaster = userOp.paymaster?.toLowerCase()
  if (paymaster != null) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    stakeInfoEntities[paymaster] = validationResult.paymasterInfo!
  }

  const entitySlots: { [addr: string]: Set<string> } = parseEntitySlots(stakeInfoEntities, tracerResults.keccak)
  Object.entries(stakeInfoEntities).forEach(([entityAddress, entStakes]) => {
    const entityTitle = getEntityTitle(userOp, entityAddress)
    const entityCallsFromEntryPoint = tracerResults.callsFromEntryPoint.filter(
      call => call.topLevelTargetAddress != null && call.topLevelTargetAddress.toLowerCase() === entityAddress.toLowerCase())
    entityCallsFromEntryPoint.forEach((entityCall) => {
      if (entityCall == null) {
        if (entityAddress.toLowerCase() === userOp.sender.toLowerCase()) {
          // should never happen... only factory, paymaster are optional.
          throw new RpcError('missing trace into account validation', ValidationErrors.InvalidFields)
        }
        return
      }
      processEntityCall(entityCall, entityAddress, entityTitle, entStakes, entitySlots, userOp as UserOperation, stakeInfoEntities, entryPointAddress, tracerResults)
    })
  })
  // return list of contract addresses by this UserOp. already known not to contain zero-sized addresses.
  const addresses = tracerResults.callsFromEntryPoint.flatMap(level => Object.keys(level.contractSize))
  const storageMap: StorageMap = {}
  tracerResults.callsFromEntryPoint.forEach(level => {
    Object.keys(level.access).forEach(addr => {
      storageMap[addr] = storageMap[addr] ?? level.access[addr].reads
    })
  })
  return [addresses, storageMap]
}

function processEntityCall (entityCall: TopLevelCallInfo, entityAddress: string, entityTitle: string, entStakes: StakeInfo, entitySlots: { [addr: string]: Set<string> }, userOp: UserOperation, stakeInfoEntities: {[addr: string]: StakeInfo}, entryPointAddress: string, tracerResults: BundlerTracerResult, depth = 0): void {
  const opcodes = entityCall.opcodes
  const access = entityCall.access

  // [OP-020]
  requireCond(!(entityCall.oog ?? false),
    `${entityTitle} internally reverts on oog`, ValidationErrors.OpcodeValidation)

  // opcodes from [OP-011]
  Object.keys(opcodes).forEach(opcode => {
    requireCond(!bannedOpCodes.has(opcode), `${entityTitle} uses banned opcode: ${opcode}`, ValidationErrors.OpcodeValidation)
    // [OP-080]
    requireCond(!opcodesOnlyInStakedEntities.has(opcode) || isStaked(entStakes),
      `unstaked ${entityTitle} uses banned opcode: ${opcode}`, ValidationErrors.OpcodeValidation)
  })

  if (entityCall.type === 'CREATE') {
    // CREATE is allowed only from the entity (factory, account) itself, not from inner contract
    // top-level is "handleOps" (or simulateValidation) itself
    requireCond(depth === 1,
      `${entityTitle} uses banned opcode: CREATE from inner call depth=${depth}`, ValidationErrors.OpcodeValidation)

    // [OP-032] If there is a `factory` (even unstaked), the `sender` contract is allowed to use `CREATE` opcode
    requireCond(
      (entityTitle === 'account' && userOp.factory != null) ||
      (entityTitle === 'factory' && isStaked(entStakes)),
        `${entityTitle} uses banned opcode: CREATE`, ValidationErrors.OpcodeValidation
    )
  }
  if (entityCall.type === 'CREATE2') {
    const factory = userOp.factory?.toLowerCase() ?? ''
    const factoryStaked = isStaked(stakeInfoEntities[factory])
    console.log(`=== CREATE2: title:${entityTitle} factory-staked:${factoryStaked} callfromsender:${entityCall.from === userOp.sender.toLowerCase()}`)
    console.log({
      stakeInfoEntities,
      userOp
    })
    requireCond(
      (entityTitle === 'account' && factoryStaked && entityCall.from === userOp.sender.toLowerCase()) || // OP-032
      (entityTitle === 'factory' && (
        entityCall.to === userOp.sender.toLowerCase() ||
        (entityCall.from === userOp.factory && isStaked(entStakes))
      )),
      `${entityTitle} uses banned opcode: CREATE2`, ValidationErrors.OpcodeValidation
    )
  }

  Object.entries(access).forEach(([addr, {
    reads,
    writes,
    transientReads,
    transientWrites
  }]) => {
    // testing read/write access on contract "addr"
    if (addr.toLowerCase() === userOp.sender.toLowerCase()) {
      // allowed to access sender's storage
      // [STO-010]
      return
    }

    if (addr.toLowerCase() === entryPointAddress.toLowerCase()) {
      // ignore storage access on entryPoint (balance/deposit of entities.
      // we block them on method calls: only allowed to deposit, never to read
      return
    }

    debug('dump keccak calculations and reads', {
      entityTitle,
      entityAddress,
      k: mapOf(tracerResults.keccak, k => keccak256(k)),
      reads
    })

    // [OP-070]: treat transient storage (TLOAD/TSTORE) just like storage.
    // scan all slots. find a referenced slot
    // at the end of the scan, we will check if the entity has stake, and report that slot if not.
    let requireStakeSlot: string | undefined
    [
      ...Object.keys(writes),
      ...Object.keys(reads),
      ...Object.keys(transientWrites ?? {}),
      ...Object.keys(transientReads ?? {})
    ].forEach(slot => {
      // slot associated with sender is allowed (e.g. token.balanceOf(sender)
      // but during initial UserOp (where there is an initCode), it is allowed only for staked entity
      if (associatedWith(slot, userOp.sender.toLowerCase(), entitySlots)) {
        if (userOp.factory != null && userOp.factory !== AddressZero) {
          // special case: account.validateUserOp is allowed to use assoc storage if factory is staked.
          // [STO-022], [STO-021]
          if (!(entityAddress.toLowerCase() === userOp.sender.toLowerCase() && isStaked(stakeInfoEntities[userOp.factory.toLowerCase()]))) {
            requireStakeSlot = slot
          }
        }
      } else if (associatedWith(slot, entityAddress, entitySlots)) {
        // [STO-032]
        // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
        requireStakeSlot = slot
      } else if (addr.toLowerCase() === entityAddress.toLowerCase()) {
        // [STO-031]
        // accessing storage member of entity itself requires stake.
        requireStakeSlot = slot
      } else if (writes[slot] == null && transientWrites[slot] == null) {
        // [STO-033]: staked entity have read-only access to any storage in non-entity contract.
        requireStakeSlot = slot
      } else {
        // accessing arbitrary storage of another contract is not allowed
        const isWrite = Object.keys(writes).includes(slot) || Object.keys(transientWrites ?? {}).includes(slot)
        const isTransient = Object.keys(transientReads ?? {}).includes(slot) || Object.keys(transientWrites ?? {}).includes(slot)
        const readWrite = isWrite ? 'write to' : 'read from'
        const transientStr = isTransient ? 'transient ' : ''
        requireCond(false,
          `${entityTitle} has forbidden ${readWrite} ${transientStr}${nameAddr(addr, stakeInfoEntities)} slot ${slot}`,
          ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes?.addr })
      }
    })

    requireCondAndStake(requireStakeSlot != null, entStakes,
      `unstaked ${entityTitle} accessed ${nameAddr(addr, stakeInfoEntities)} slot ${requireStakeSlot}`, entityTitle, access)
  })

  // the only contract we allow to access before its deployment is the "sender" itself, which gets created.
  let illegalZeroCodeAccess: any
  for (const addr of Object.keys(entityCall.contractSize)) {
    // [OP-042]
    if (addr.toLowerCase() !== userOp.sender.toLowerCase() && addr.toLowerCase() !== entryPointAddress.toLowerCase() && entityCall.contractSize[addr].contractSize <= 2) {
      illegalZeroCodeAccess = entityCall.contractSize[addr]
      illegalZeroCodeAccess.address = addr
      break
    }
  }
  // [OP-041]
  requireCond(
    illegalZeroCodeAccess == null,
    `${entityTitle} accesses un-deployed contract address ${illegalZeroCodeAccess?.address as string} with opcode ${illegalZeroCodeAccess?.opcode as string}`,
    ValidationErrors.OpcodeValidation)

  let illegalEntryPointCodeAccess
  for (const addr of Object.keys(entityCall.extCodeAccessInfo)) {
    if (addr.toLowerCase() === entryPointAddress.toLowerCase()) {
      illegalEntryPointCodeAccess = entityCall.extCodeAccessInfo[addr]
      break
    }
  }
  requireCond(
    illegalEntryPointCodeAccess == null,
    `${entityTitle} accesses EntryPoint contract address ${entryPointAddress} with opcode ${illegalEntryPointCodeAccess}`,
    ValidationErrors.OpcodeValidation)

  // Recursively handling all subcalls to check validation rules
  if (entityCall.calls != null) {
    entityCall.calls.forEach((call: any) => {
      processEntityCall(call, entityAddress, entityTitle, entStakes, entitySlots, userOp, stakeInfoEntities, entryPointAddress, tracerResults, depth + 1)
    })
  }
}

// helper method: if condition is true, then entity must be staked.
function requireCondAndStake (cond: boolean, entStake: StakeInfo | undefined, failureMessage: string, entityTitle: string, access: { [address: string]: AccessInfo }): void {
  if (!cond) {
    return
  }
  if (entStake == null) {
    throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`)
  }
  requireCond(isStaked(entStake),
    failureMessage, ValidationErrors.OpcodeValidation, { [entityTitle]: entStake?.addr })

  // TODO: check real minimum stake values
}

// check if the given entity is staked
function isStaked (entStake?: StakeInfo): boolean {
  return entStake != null && BigNumber.from(1).lte(entStake.stake) && BigNumber.from(1).lte(entStake.unstakeDelaySec)
}

// if addr is current account/paymaster/factory, then return that title
// otherwise, return addr as-is
function nameAddr (addr: string, stakeInfoEntities: {[addr: string]: StakeInfo}): string {
  const [title] = Object.entries(stakeInfoEntities).find(([title, info]) =>
    info?.addr.toLowerCase() === addr.toLowerCase()) ?? []

  return title ?? addr
}

// return true if the given slot is associated with the given address, given the known keccak operations:
// @param slot the SLOAD/SSTORE slot address we're testing
// @param addr - the address we try to check for association with
// @param reverseKeccak - a mapping we built for keccak values that contained the address
function associatedWith (slot: string, addr: string, entitySlots: { [addr: string]: Set<string> }): boolean {
  const addrPadded = hexZeroPad(addr, 32).toLowerCase()
  if (slot === addrPadded) {
    return true
  }
  const k = entitySlots[addr]
  if (k == null) {
    return false
  }
  const slotN = BigNumber.from(slot)
  // scan all slot entries to check of the given slot is within a structure, starting at that offset.
  // assume a maximum size on a (static) structure size.
  for (const k1 of k.keys()) {
    const kn = BigNumber.from(k1)
    if (slotN.gte(kn) && slotN.lt(kn.add(128))) {
      return true
    }
  }
  return false
}
